import org.apache.tools.ant.filters.ReplaceTokens

plugins {
	id "com.jfrog.bintray" version "1.6"
}

apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'signing'
apply plugin: 'eclipse'

def versionObj = new Version(major: 1, minor: 3, revision: 0)
group = "net.dv8tion"
archivesBaseName = "JDA"
version = "${versionObj.toString()}"

sourceCompatibility = 1.8
targetCompatibility = 1.8

tasks.eclipse.dependsOn(cleanEclipse)

def filteredSourceDir = file("${buildDir}/filtered")

//This is to fix eclipse's stupidity when first setting up the project.
// It thinks that "filtered" should be a development source folder and cries when it doesn't exist (gradlew clean)
eclipse {
	classpath {
		file {
			withXml {
				def sb = it.asString()
				sb.replace(0, sb.length(), sb.toString().replace("\n    <classpathentry kind=\"src\" path=\"build/filtered\"/>", ""));
			}
		}
	}
}


sourceSets {
	// This source set will contain all sources that we filter
	filtered {
		java {
			srcDirs = [
					filteredSourceDir,
					"src/test/java",

					"src/examples/java"
			]
		}
	}
}



// copy the main sources and filter any '@buildVersion@' occurences. 
task processVersion (type: Copy) {
	from sourceSets.main.java
	into filteredSourceDir
	filter(ReplaceTokens, tokens: [
			versionMajor: versionObj.getMajor(),
			versionMinor: versionObj.getMinor(),
			versionRevision: versionObj.getRevision(),
			versionBuild: versionObj.getBuild()
	])
}

jar {
	baseName = project.name
	manifest {
		attributes 'Implementation-Version': version
	}
}

task javadocJar(type: Jar) {
	classifier = 'javadoc'
	from javadoc
}

task sourcesJar(type: Jar) {
	classifier = 'sources'
	from sourceSets.filtered.java
}

//create a single Jar with all dependencies
task fatJar(type: Jar) {

	manifest {
		attributes 'Implementation-Version': version

	}
	baseName = project.name + '-withDependencies'
	from { configurations.compile.collect {
		dependency ->
		if (dependency.isDirectory()) { //If it is a folder, just include the folder in its entirety
			return dependency
		} else {	//If it isn't a folder, put it in a zipTree. if it is a zip or jar the contents will be extracted.
			return zipTree(dependency)
		}
	}}
	with jar
}

artifacts {
	archives javadocJar, sourcesJar
}

signing {
	sign configurations.archives
}
repositories {
	jcenter()
}

dependencies {
	//General Utility
	compile 'org.apache.commons:commons-lang3:3.4'
	compile 'org.json:json:20150729'

	//Native Library Support
	compile 'net.java.dev.jna:jna:4.2.1'

	//Web Connection Support
	compile 'com.neovisionaries:nv-websocket-client:1.16'
	compile 'com.mashape.unirest:unirest-java:1.4.7'

	//Audio Support
	compile 'com.googlecode.soundlibs:tritonus-share:0.3.7-2'   //Shared audio code
	compile 'org.tritonus:tritonus-dsp:0.3.6'				   //Volume control
	compile 'com.googlecode.soundlibs:mp3spi:1.9.5-1'		   //MP3 support
	compile 'net.sourceforge.jaadec:jaad:0.8.5'				 //AAC supports
	compile 'jflac:jflac:1.3'								   //FLAC support
	
	// Added Libs
	compile 'org.jsoup:jsoup:1.8.3'		// Notehub Uploader
}

class Version {
	int major, minor, revision

	String getMajor() {
		"${major}"
	}

	String getMinor() {
		"${minor}"
	}

	String getRevision() {
		"${revision}"
	}

	String getBuild() {
		System.getenv("BUILD_NUMBER") ? System.getenv("BUILD_NUMBER") : System.getProperty("BUILD_NUMBER") != null ? System.getProperty("BUILD_NUMBER") : "DEV"
	}

	String toString() {
		"${getMajor()}.${getMinor()}.${getRevision()}_${getBuild()}"
	}
}

uploadArchives {
  onlyIf {
	System.getenv("BUILD_NUMBER")
  }
  repositories {
	mavenDeployer {
	  beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

	  repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
		authentication(userName: ossrhUsername, password: ossrhPassword)
	  }

	  snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
		authentication(userName: ossrhUsername, password: ossrhPassword)
	  }

	  pom.project {
		name 'JDA'
		packaging 'jar'
		// optionally artifactId can be defined here 
		description 'A wrapping of the Discord REST api and its Websocket-Events for Java.'
		url 'https://github.com/DV8FromTheWorld/JDA'

		scm {
		  connection 'scm:git:git@github.com:DV8FromTheWorld/JDA.git'
		  developerConnection 'scm:git:git@github.com:DV8FromTheWorld/JDA.git'
		  url 'scm:git:git@github.com:DV8FromTheWorld/JDA.git'
		}

		licenses {
		  license {
			name 'The Apache License, Version 2.0'
			url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
		  }
		}

		developers {
		  developer {
			id 'DV8FromTheWorld'
			name 'Austin Keener'
			email 'keeneraustin@yahoo.com'
		  }
		  developer {
			id 'Kantekugel'
			name 'Michael Ritter'
			email 'ritter.michael92@gmail.com'
		  }
		}
	  }.withXml {
		  //If we use a repository that isn't just MavenCentral
		  if (project.getRepositories().size() > 1)
		  {
			  int i = 0
			  def reposNode = asNode().appendNode("repositories")
			  project.getRepositories().stream().forEach {
				  repo ->

				  //Ignore the MavenCentral repository. Don't need to add it.
				  if (!repo.getProperties().get("url").toString().equals("https://repo1.maven.org/maven2/"))
				  {
					  def repoNode = reposNode.appendNode("repository")
					  repoNode.appendNode("id", "JDA-repo-" + i)
					  repoNode.appendNode("name", "JDA Repo " + i)
					  repoNode.appendNode("url", repo.getProperties().get("url"));
					  i++
				  }
			  }
		  }
	  }
	}
  }
}

bintray {
	user = bintrayUsername
	key = bintrayApiKey
	pkg {
		repo = 'maven'
		name = 'JDA'
		licenses = ['Apache-2.0']
		vcsUrl = 'https://github.com/DV8FromTheWorld/JDA.git'
		configurations = ['archives']
		publish = true;
		version {
			name = project.version
			released  = new Date()
		}
	}
}

bintrayUpload {
	onlyIf {
		System.getenv("BUILD_NUMBER")
	}
}

// tell the compileJava task to compile the filtered source 
compileJava.source = sourceSets.filtered.java
compileJava.dependsOn processVersion

//Creates the w/ dependencies jar.
uploadArchives.dependsOn fatJar
bintrayUpload.dependsOn uploadArchives

//If we don't have the username and password for uploading, we probably also
// cant sign the archives, so skip these tasks.
signArchives.onlyIf { !ossrhUsername.isEmpty() && !ossrhPassword.isEmpty() }
uploadArchives.onlyIf {!ossrhUsername.isEmpty() && !ossrhPassword.isEmpty() }
bintrayUpload.onlyIf {!bintrayUsername.isEmpty() && !bintrayApiKey.isEmpty() }

// ### Additions ### 

task exportDependencies(type: Copy, overwrite: true) {
	dependsOn build 
	File directory = new File(projectDir.getParentFile(), "export/lib/")
    directory.mkdirs()
	into directory
	from jar
	from configurations.runtime
}

task export (dependsOn: exportDependencies, type: Copy, overwrite: true) {
	dependsOn build, exportDependencies 
}